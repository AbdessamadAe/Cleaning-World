Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> world_def function_list_opt agent_def
Rule 2     function_list_opt -> <empty>
Rule 3     function_list_opt -> function_list
Rule 4     function_list -> function_decl
Rule 5     function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE
Rule 6     param_list_opt -> <empty>
Rule 7     param_list_opt -> param_list
Rule 8     param_list -> param_decl
Rule 9     param_list -> param_decl COMMA param_list
Rule 10    param_decl -> ID
Rule 11    type -> TYPE_INT
Rule 12    type -> TYPE_VOID
Rule 13    world_def -> WORLD ID LBRACE world_body RBRACE
Rule 14    world_body -> world_stmt
Rule 15    world_body -> world_stmt world_body
Rule 16    world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
Rule 17    world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
Rule 18    world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
Rule 19    world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
Rule 20    world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
Rule 21    agent_def -> AGENT ID LBRACE stmt_list RBRACE
Rule 22    stmt_list -> stmt
Rule 23    stmt_list -> stmt stmt_list
Rule 24    stmt -> VAR ID ASSIGN expr SEMICOLON
Rule 25    stmt -> ID ASSIGN expr SEMICOLON
Rule 26    stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
Rule 27    stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON
Rule 28    stmt -> MOVE SEMICOLON
Rule 29    stmt -> TURN turn_dir SEMICOLON
Rule 30    stmt -> CLEAN SEMICOLON
Rule 31    stmt -> BACKTRACK SEMICOLON
Rule 32    stmt -> REPORT expr SEMICOLON
Rule 33    stmt -> RETURN expr SEMICOLON
Rule 34    stmt -> function_call SEMICOLON
Rule 35    turn_dir -> LEFT
Rule 36    turn_dir -> RIGHT
Rule 37    function_call -> ID LPAREN arg_list_opt RPAREN
Rule 38    arg_list_opt -> <empty>
Rule 39    arg_list_opt -> arg_list
Rule 40    arg_list -> expr
Rule 41    arg_list -> expr COMMA arg_list
Rule 42    condition -> SENSE sense_expr
Rule 43    condition -> NOT condition
Rule 44    condition -> condition AND condition
Rule 45    condition -> condition OR condition
Rule 46    condition -> expr relop expr
Rule 47    condition -> UNVISITED
Rule 48    sense_expr -> DIRT
Rule 49    sense_expr -> OBSTACLE
Rule 50    sense_expr -> EXIT
Rule 51    sense_expr -> ENTRY
Rule 52    relop -> EQ
Rule 53    relop -> NEQ
Rule 54    relop -> LT
Rule 55    relop -> GT
Rule 56    expr -> term PLUS expr
Rule 57    expr -> term MINUS expr
Rule 58    expr -> term
Rule 59    term -> ID
Rule 60    term -> INT_LIT
Rule 61    term -> function_call
Rule 62    dir -> N
Rule 63    dir -> E
Rule 64    dir -> S
Rule 65    dir -> W

Terminals, with rules where they appear

AGENT                : 21
AND                  : 44
ASSIGN               : 24 25
BACKTRACK            : 31
CLEAN                : 30
COMMA                : 9 16 17 17 18 18 19 20 41
DIRT                 : 48
DIRT_DEF             : 20
DO                   : 27
E                    : 63
ELSE                 : 26
ENDIF                : 26
ENDWHILE             : 27
ENTRY                : 51
ENTRY_DEF            : 17
EQ                   : 52
EXIT                 : 50
EXIT_DEF             : 18
FUNC                 : 5
GT                   : 55
ID                   : 5 10 13 21 24 25 37 59
IF                   : 26
INT_LIT              : 16 16 17 17 18 18 19 19 20 20 60
LBRACE               : 5 13 21
LEFT                 : 35
LPAREN               : 5 16 17 18 19 20 37
LT                   : 54
MINUS                : 57
MOVE                 : 28
N                    : 62
NEQ                  : 53
NOT                  : 43
OBSTACLE             : 49
OBSTACLE_DEF         : 19
OR                   : 45
PLUS                 : 56
RBRACE               : 5 13 21
REPORT               : 32
RETURN               : 33
RETURNS              : 5
RIGHT                : 36
RPAREN               : 5 16 17 18 19 20 37
S                    : 64
SEMICOLON            : 16 17 18 19 20 24 25 26 27 28 29 30 31 32 33 34
SENSE                : 42
SIZE                 : 16
THEN                 : 26
TURN                 : 29
TYPE_INT             : 11
TYPE_VOID            : 12
UNVISITED            : 47
VAR                  : 24
W                    : 65
WHILE                : 27
WORLD                : 13
error                : 

Nonterminals, with rules where they appear

agent_def            : 1
arg_list             : 39 41
arg_list_opt         : 37
condition            : 26 27 43 44 44 45 45
dir                  : 17 18
expr                 : 24 25 32 33 40 41 46 46 56 57
function_call        : 34 61
function_decl        : 4
function_list        : 3
function_list_opt    : 1
param_decl           : 8 9
param_list           : 7 9
param_list_opt       : 5
program              : 0
relop                : 46
sense_expr           : 42
stmt                 : 22 23
stmt_list            : 5 21 23 26 26 27
term                 : 56 57 58
turn_dir             : 29
type                 : 5
world_body           : 13 15
world_def            : 1
world_stmt           : 14 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . world_def function_list_opt agent_def
    (13) world_def -> . WORLD ID LBRACE world_body RBRACE

    WORLD           shift and go to state 3

    program                        shift and go to state 1
    world_def                      shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> world_def . function_list_opt agent_def
    (2) function_list_opt -> .
    (3) function_list_opt -> . function_list
    (4) function_list -> . function_decl
    (5) function_decl -> . FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE

    AGENT           reduce using rule 2 (function_list_opt -> .)
    FUNC            shift and go to state 7

    function_list_opt              shift and go to state 4
    function_list                  shift and go to state 5
    function_decl                  shift and go to state 6

state 3

    (13) world_def -> WORLD . ID LBRACE world_body RBRACE

    ID              shift and go to state 8


state 4

    (1) program -> world_def function_list_opt . agent_def
    (21) agent_def -> . AGENT ID LBRACE stmt_list RBRACE

    AGENT           shift and go to state 10

    agent_def                      shift and go to state 9

state 5

    (3) function_list_opt -> function_list .

    AGENT           reduce using rule 3 (function_list_opt -> function_list .)


state 6

    (4) function_list -> function_decl .

    AGENT           reduce using rule 4 (function_list -> function_decl .)


state 7

    (5) function_decl -> FUNC . ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE

    ID              shift and go to state 11


state 8

    (13) world_def -> WORLD ID . LBRACE world_body RBRACE

    LBRACE          shift and go to state 12


state 9

    (1) program -> world_def function_list_opt agent_def .

    $end            reduce using rule 1 (program -> world_def function_list_opt agent_def .)


state 10

    (21) agent_def -> AGENT . ID LBRACE stmt_list RBRACE

    ID              shift and go to state 13


state 11

    (5) function_decl -> FUNC ID . LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 14


state 12

    (13) world_def -> WORLD ID LBRACE . world_body RBRACE
    (14) world_body -> . world_stmt
    (15) world_body -> . world_stmt world_body
    (16) world_stmt -> . SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
    (17) world_stmt -> . ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
    (18) world_stmt -> . EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
    (19) world_stmt -> . OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
    (20) world_stmt -> . DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    SIZE            shift and go to state 17
    ENTRY_DEF       shift and go to state 18
    EXIT_DEF        shift and go to state 19
    OBSTACLE_DEF    shift and go to state 20
    DIRT_DEF        shift and go to state 21

    world_body                     shift and go to state 15
    world_stmt                     shift and go to state 16

state 13

    (21) agent_def -> AGENT ID . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 22


state 14

    (5) function_decl -> FUNC ID LPAREN . param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE
    (6) param_list_opt -> .
    (7) param_list_opt -> . param_list
    (8) param_list -> . param_decl
    (9) param_list -> . param_decl COMMA param_list
    (10) param_decl -> . ID

    RPAREN          reduce using rule 6 (param_list_opt -> .)
    ID              shift and go to state 23

    param_list_opt                 shift and go to state 24
    param_list                     shift and go to state 25
    param_decl                     shift and go to state 26

state 15

    (13) world_def -> WORLD ID LBRACE world_body . RBRACE

    RBRACE          shift and go to state 27


state 16

    (14) world_body -> world_stmt .
    (15) world_body -> world_stmt . world_body
    (14) world_body -> . world_stmt
    (15) world_body -> . world_stmt world_body
    (16) world_stmt -> . SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
    (17) world_stmt -> . ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
    (18) world_stmt -> . EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON
    (19) world_stmt -> . OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON
    (20) world_stmt -> . DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    RBRACE          reduce using rule 14 (world_body -> world_stmt .)
    SIZE            shift and go to state 17
    ENTRY_DEF       shift and go to state 18
    EXIT_DEF        shift and go to state 19
    OBSTACLE_DEF    shift and go to state 20
    DIRT_DEF        shift and go to state 21

    world_stmt                     shift and go to state 16
    world_body                     shift and go to state 28

state 17

    (16) world_stmt -> SIZE . LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    LPAREN          shift and go to state 29


state 18

    (17) world_stmt -> ENTRY_DEF . LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    LPAREN          shift and go to state 30


state 19

    (18) world_stmt -> EXIT_DEF . LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    LPAREN          shift and go to state 31


state 20

    (19) world_stmt -> OBSTACLE_DEF . LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    LPAREN          shift and go to state 32


state 21

    (20) world_stmt -> DIRT_DEF . LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    LPAREN          shift and go to state 33


state 22

    (21) agent_def -> AGENT ID LBRACE . stmt_list RBRACE
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt_list                      shift and go to state 35
    stmt                           shift and go to state 36
    function_call                  shift and go to state 46

state 23

    (10) param_decl -> ID .

    COMMA           reduce using rule 10 (param_decl -> ID .)
    RPAREN          reduce using rule 10 (param_decl -> ID .)


state 24

    (5) function_decl -> FUNC ID LPAREN param_list_opt . RPAREN RETURNS type LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 47


state 25

    (7) param_list_opt -> param_list .

    RPAREN          reduce using rule 7 (param_list_opt -> param_list .)


state 26

    (8) param_list -> param_decl .
    (9) param_list -> param_decl . COMMA param_list

    RPAREN          reduce using rule 8 (param_list -> param_decl .)
    COMMA           shift and go to state 48


state 27

    (13) world_def -> WORLD ID LBRACE world_body RBRACE .

    FUNC            reduce using rule 13 (world_def -> WORLD ID LBRACE world_body RBRACE .)
    AGENT           reduce using rule 13 (world_def -> WORLD ID LBRACE world_body RBRACE .)


state 28

    (15) world_body -> world_stmt world_body .

    RBRACE          reduce using rule 15 (world_body -> world_stmt world_body .)


state 29

    (16) world_stmt -> SIZE LPAREN . INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 49


state 30

    (17) world_stmt -> ENTRY_DEF LPAREN . INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    INT_LIT         shift and go to state 50


state 31

    (18) world_stmt -> EXIT_DEF LPAREN . INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    INT_LIT         shift and go to state 51


state 32

    (19) world_stmt -> OBSTACLE_DEF LPAREN . INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 52


state 33

    (20) world_stmt -> DIRT_DEF LPAREN . INT_LIT COMMA INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 53


state 34

    (25) stmt -> ID . ASSIGN expr SEMICOLON
    (37) function_call -> ID . LPAREN arg_list_opt RPAREN

    ASSIGN          shift and go to state 54
    LPAREN          shift and go to state 55


state 35

    (21) agent_def -> AGENT ID LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 56


state 36

    (22) stmt_list -> stmt .
    (23) stmt_list -> stmt . stmt_list
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    RBRACE          reduce using rule 22 (stmt_list -> stmt .)
    ELSE            reduce using rule 22 (stmt_list -> stmt .)
    ENDWHILE        reduce using rule 22 (stmt_list -> stmt .)
    ENDIF           reduce using rule 22 (stmt_list -> stmt .)
    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt                           shift and go to state 36
    stmt_list                      shift and go to state 57
    function_call                  shift and go to state 46

state 37

    (24) stmt -> VAR . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 58


state 38

    (26) stmt -> IF . condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (42) condition -> . SENSE sense_expr
    (43) condition -> . NOT condition
    (44) condition -> . condition AND condition
    (45) condition -> . condition OR condition
    (46) condition -> . expr relop expr
    (47) condition -> . UNVISITED
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    SENSE           shift and go to state 60
    NOT             shift and go to state 61
    UNVISITED       shift and go to state 63
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    condition                      shift and go to state 59
    expr                           shift and go to state 62
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 39

    (27) stmt -> WHILE . condition DO stmt_list ENDWHILE SEMICOLON
    (42) condition -> . SENSE sense_expr
    (43) condition -> . NOT condition
    (44) condition -> . condition AND condition
    (45) condition -> . condition OR condition
    (46) condition -> . expr relop expr
    (47) condition -> . UNVISITED
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    SENSE           shift and go to state 60
    NOT             shift and go to state 61
    UNVISITED       shift and go to state 63
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    condition                      shift and go to state 68
    expr                           shift and go to state 62
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 40

    (28) stmt -> MOVE . SEMICOLON

    SEMICOLON       shift and go to state 69


state 41

    (29) stmt -> TURN . turn_dir SEMICOLON
    (35) turn_dir -> . LEFT
    (36) turn_dir -> . RIGHT

    LEFT            shift and go to state 71
    RIGHT           shift and go to state 72

    turn_dir                       shift and go to state 70

state 42

    (30) stmt -> CLEAN . SEMICOLON

    SEMICOLON       shift and go to state 73


state 43

    (31) stmt -> BACKTRACK . SEMICOLON

    SEMICOLON       shift and go to state 74


state 44

    (32) stmt -> REPORT . expr SEMICOLON
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 75
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 45

    (33) stmt -> RETURN . expr SEMICOLON
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 76
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 46

    (34) stmt -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 77


state 47

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN . RETURNS type LBRACE stmt_list RBRACE

    RETURNS         shift and go to state 78


state 48

    (9) param_list -> param_decl COMMA . param_list
    (8) param_list -> . param_decl
    (9) param_list -> . param_decl COMMA param_list
    (10) param_decl -> . ID

    ID              shift and go to state 23

    param_decl                     shift and go to state 26
    param_list                     shift and go to state 79

state 49

    (16) world_stmt -> SIZE LPAREN INT_LIT . COMMA INT_LIT RPAREN SEMICOLON

    COMMA           shift and go to state 80


state 50

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT . COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    COMMA           shift and go to state 81


state 51

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT . COMMA INT_LIT COMMA dir RPAREN SEMICOLON

    COMMA           shift and go to state 82


state 52

    (19) world_stmt -> OBSTACLE_DEF LPAREN INT_LIT . COMMA INT_LIT RPAREN SEMICOLON

    COMMA           shift and go to state 83


state 53

    (20) world_stmt -> DIRT_DEF LPAREN INT_LIT . COMMA INT_LIT RPAREN SEMICOLON

    COMMA           shift and go to state 84


state 54

    (25) stmt -> ID ASSIGN . expr SEMICOLON
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 85
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 55

    (37) function_call -> ID LPAREN . arg_list_opt RPAREN
    (38) arg_list_opt -> .
    (39) arg_list_opt -> . arg_list
    (40) arg_list -> . expr
    (41) arg_list -> . expr COMMA arg_list
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    RPAREN          reduce using rule 38 (arg_list_opt -> .)
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    arg_list_opt                   shift and go to state 86
    arg_list                       shift and go to state 87
    expr                           shift and go to state 88
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 56

    (21) agent_def -> AGENT ID LBRACE stmt_list RBRACE .

    $end            reduce using rule 21 (agent_def -> AGENT ID LBRACE stmt_list RBRACE .)


state 57

    (23) stmt_list -> stmt stmt_list .

    RBRACE          reduce using rule 23 (stmt_list -> stmt stmt_list .)
    ELSE            reduce using rule 23 (stmt_list -> stmt stmt_list .)
    ENDWHILE        reduce using rule 23 (stmt_list -> stmt stmt_list .)
    ENDIF           reduce using rule 23 (stmt_list -> stmt stmt_list .)


state 58

    (24) stmt -> VAR ID . ASSIGN expr SEMICOLON

    ASSIGN          shift and go to state 89


state 59

    (26) stmt -> IF condition . THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (44) condition -> condition . AND condition
    (45) condition -> condition . OR condition

    THEN            shift and go to state 90
    AND             shift and go to state 91
    OR              shift and go to state 92


state 60

    (42) condition -> SENSE . sense_expr
    (48) sense_expr -> . DIRT
    (49) sense_expr -> . OBSTACLE
    (50) sense_expr -> . EXIT
    (51) sense_expr -> . ENTRY

    DIRT            shift and go to state 94
    OBSTACLE        shift and go to state 95
    EXIT            shift and go to state 96
    ENTRY           shift and go to state 97

    sense_expr                     shift and go to state 93

state 61

    (43) condition -> NOT . condition
    (42) condition -> . SENSE sense_expr
    (43) condition -> . NOT condition
    (44) condition -> . condition AND condition
    (45) condition -> . condition OR condition
    (46) condition -> . expr relop expr
    (47) condition -> . UNVISITED
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    SENSE           shift and go to state 60
    NOT             shift and go to state 61
    UNVISITED       shift and go to state 63
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    condition                      shift and go to state 98
    expr                           shift and go to state 62
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 62

    (46) condition -> expr . relop expr
    (52) relop -> . EQ
    (53) relop -> . NEQ
    (54) relop -> . LT
    (55) relop -> . GT

    EQ              shift and go to state 100
    NEQ             shift and go to state 101
    LT              shift and go to state 102
    GT              shift and go to state 103

    relop                          shift and go to state 99

state 63

    (47) condition -> UNVISITED .

    THEN            reduce using rule 47 (condition -> UNVISITED .)
    AND             reduce using rule 47 (condition -> UNVISITED .)
    OR              reduce using rule 47 (condition -> UNVISITED .)
    DO              reduce using rule 47 (condition -> UNVISITED .)


state 64

    (56) expr -> term . PLUS expr
    (57) expr -> term . MINUS expr
    (58) expr -> term .

    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    EQ              reduce using rule 58 (expr -> term .)
    NEQ             reduce using rule 58 (expr -> term .)
    LT              reduce using rule 58 (expr -> term .)
    GT              reduce using rule 58 (expr -> term .)
    SEMICOLON       reduce using rule 58 (expr -> term .)
    COMMA           reduce using rule 58 (expr -> term .)
    RPAREN          reduce using rule 58 (expr -> term .)
    THEN            reduce using rule 58 (expr -> term .)
    AND             reduce using rule 58 (expr -> term .)
    OR              reduce using rule 58 (expr -> term .)
    DO              reduce using rule 58 (expr -> term .)


state 65

    (59) term -> ID .
    (37) function_call -> ID . LPAREN arg_list_opt RPAREN

    PLUS            reduce using rule 59 (term -> ID .)
    MINUS           reduce using rule 59 (term -> ID .)
    EQ              reduce using rule 59 (term -> ID .)
    NEQ             reduce using rule 59 (term -> ID .)
    LT              reduce using rule 59 (term -> ID .)
    GT              reduce using rule 59 (term -> ID .)
    SEMICOLON       reduce using rule 59 (term -> ID .)
    COMMA           reduce using rule 59 (term -> ID .)
    RPAREN          reduce using rule 59 (term -> ID .)
    THEN            reduce using rule 59 (term -> ID .)
    AND             reduce using rule 59 (term -> ID .)
    OR              reduce using rule 59 (term -> ID .)
    DO              reduce using rule 59 (term -> ID .)
    LPAREN          shift and go to state 55


state 66

    (60) term -> INT_LIT .

    PLUS            reduce using rule 60 (term -> INT_LIT .)
    MINUS           reduce using rule 60 (term -> INT_LIT .)
    EQ              reduce using rule 60 (term -> INT_LIT .)
    NEQ             reduce using rule 60 (term -> INT_LIT .)
    LT              reduce using rule 60 (term -> INT_LIT .)
    GT              reduce using rule 60 (term -> INT_LIT .)
    SEMICOLON       reduce using rule 60 (term -> INT_LIT .)
    COMMA           reduce using rule 60 (term -> INT_LIT .)
    RPAREN          reduce using rule 60 (term -> INT_LIT .)
    THEN            reduce using rule 60 (term -> INT_LIT .)
    AND             reduce using rule 60 (term -> INT_LIT .)
    OR              reduce using rule 60 (term -> INT_LIT .)
    DO              reduce using rule 60 (term -> INT_LIT .)


state 67

    (61) term -> function_call .

    PLUS            reduce using rule 61 (term -> function_call .)
    MINUS           reduce using rule 61 (term -> function_call .)
    EQ              reduce using rule 61 (term -> function_call .)
    NEQ             reduce using rule 61 (term -> function_call .)
    LT              reduce using rule 61 (term -> function_call .)
    GT              reduce using rule 61 (term -> function_call .)
    SEMICOLON       reduce using rule 61 (term -> function_call .)
    COMMA           reduce using rule 61 (term -> function_call .)
    RPAREN          reduce using rule 61 (term -> function_call .)
    THEN            reduce using rule 61 (term -> function_call .)
    AND             reduce using rule 61 (term -> function_call .)
    OR              reduce using rule 61 (term -> function_call .)
    DO              reduce using rule 61 (term -> function_call .)


state 68

    (27) stmt -> WHILE condition . DO stmt_list ENDWHILE SEMICOLON
    (44) condition -> condition . AND condition
    (45) condition -> condition . OR condition

    DO              shift and go to state 106
    AND             shift and go to state 91
    OR              shift and go to state 92


state 69

    (28) stmt -> MOVE SEMICOLON .

    VAR             reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    ID              reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    IF              reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    WHILE           reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    MOVE            reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    TURN            reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    CLEAN           reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    BACKTRACK       reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    REPORT          reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    RETURN          reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    RBRACE          reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    ELSE            reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    ENDWHILE        reduce using rule 28 (stmt -> MOVE SEMICOLON .)
    ENDIF           reduce using rule 28 (stmt -> MOVE SEMICOLON .)


state 70

    (29) stmt -> TURN turn_dir . SEMICOLON

    SEMICOLON       shift and go to state 107


state 71

    (35) turn_dir -> LEFT .

    SEMICOLON       reduce using rule 35 (turn_dir -> LEFT .)


state 72

    (36) turn_dir -> RIGHT .

    SEMICOLON       reduce using rule 36 (turn_dir -> RIGHT .)


state 73

    (30) stmt -> CLEAN SEMICOLON .

    VAR             reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    ID              reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    IF              reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    WHILE           reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    MOVE            reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    TURN            reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    CLEAN           reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    BACKTRACK       reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    REPORT          reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    RETURN          reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    RBRACE          reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    ELSE            reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    ENDWHILE        reduce using rule 30 (stmt -> CLEAN SEMICOLON .)
    ENDIF           reduce using rule 30 (stmt -> CLEAN SEMICOLON .)


state 74

    (31) stmt -> BACKTRACK SEMICOLON .

    VAR             reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    ID              reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    IF              reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    WHILE           reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    MOVE            reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    TURN            reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    CLEAN           reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    BACKTRACK       reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    REPORT          reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    RETURN          reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    RBRACE          reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    ELSE            reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    ENDWHILE        reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)
    ENDIF           reduce using rule 31 (stmt -> BACKTRACK SEMICOLON .)


state 75

    (32) stmt -> REPORT expr . SEMICOLON

    SEMICOLON       shift and go to state 108


state 76

    (33) stmt -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 109


state 77

    (34) stmt -> function_call SEMICOLON .

    VAR             reduce using rule 34 (stmt -> function_call SEMICOLON .)
    ID              reduce using rule 34 (stmt -> function_call SEMICOLON .)
    IF              reduce using rule 34 (stmt -> function_call SEMICOLON .)
    WHILE           reduce using rule 34 (stmt -> function_call SEMICOLON .)
    MOVE            reduce using rule 34 (stmt -> function_call SEMICOLON .)
    TURN            reduce using rule 34 (stmt -> function_call SEMICOLON .)
    CLEAN           reduce using rule 34 (stmt -> function_call SEMICOLON .)
    BACKTRACK       reduce using rule 34 (stmt -> function_call SEMICOLON .)
    REPORT          reduce using rule 34 (stmt -> function_call SEMICOLON .)
    RETURN          reduce using rule 34 (stmt -> function_call SEMICOLON .)
    RBRACE          reduce using rule 34 (stmt -> function_call SEMICOLON .)
    ELSE            reduce using rule 34 (stmt -> function_call SEMICOLON .)
    ENDWHILE        reduce using rule 34 (stmt -> function_call SEMICOLON .)
    ENDIF           reduce using rule 34 (stmt -> function_call SEMICOLON .)


state 78

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS . type LBRACE stmt_list RBRACE
    (11) type -> . TYPE_INT
    (12) type -> . TYPE_VOID

    TYPE_INT        shift and go to state 111
    TYPE_VOID       shift and go to state 112

    type                           shift and go to state 110

state 79

    (9) param_list -> param_decl COMMA param_list .

    RPAREN          reduce using rule 9 (param_list -> param_decl COMMA param_list .)


state 80

    (16) world_stmt -> SIZE LPAREN INT_LIT COMMA . INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 113


state 81

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA . INT_LIT COMMA dir RPAREN SEMICOLON

    INT_LIT         shift and go to state 114


state 82

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA . INT_LIT COMMA dir RPAREN SEMICOLON

    INT_LIT         shift and go to state 115


state 83

    (19) world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA . INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 116


state 84

    (20) world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA . INT_LIT RPAREN SEMICOLON

    INT_LIT         shift and go to state 117


state 85

    (25) stmt -> ID ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 118


state 86

    (37) function_call -> ID LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 119


state 87

    (39) arg_list_opt -> arg_list .

    RPAREN          reduce using rule 39 (arg_list_opt -> arg_list .)


state 88

    (40) arg_list -> expr .
    (41) arg_list -> expr . COMMA arg_list

    RPAREN          reduce using rule 40 (arg_list -> expr .)
    COMMA           shift and go to state 120


state 89

    (24) stmt -> VAR ID ASSIGN . expr SEMICOLON
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 121
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 90

    (26) stmt -> IF condition THEN . stmt_list ELSE stmt_list ENDIF SEMICOLON
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt_list                      shift and go to state 122
    stmt                           shift and go to state 36
    function_call                  shift and go to state 46

state 91

    (44) condition -> condition AND . condition
    (42) condition -> . SENSE sense_expr
    (43) condition -> . NOT condition
    (44) condition -> . condition AND condition
    (45) condition -> . condition OR condition
    (46) condition -> . expr relop expr
    (47) condition -> . UNVISITED
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    SENSE           shift and go to state 60
    NOT             shift and go to state 61
    UNVISITED       shift and go to state 63
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    condition                      shift and go to state 123
    expr                           shift and go to state 62
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 92

    (45) condition -> condition OR . condition
    (42) condition -> . SENSE sense_expr
    (43) condition -> . NOT condition
    (44) condition -> . condition AND condition
    (45) condition -> . condition OR condition
    (46) condition -> . expr relop expr
    (47) condition -> . UNVISITED
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    SENSE           shift and go to state 60
    NOT             shift and go to state 61
    UNVISITED       shift and go to state 63
    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    condition                      shift and go to state 124
    expr                           shift and go to state 62
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 93

    (42) condition -> SENSE sense_expr .

    THEN            reduce using rule 42 (condition -> SENSE sense_expr .)
    AND             reduce using rule 42 (condition -> SENSE sense_expr .)
    OR              reduce using rule 42 (condition -> SENSE sense_expr .)
    DO              reduce using rule 42 (condition -> SENSE sense_expr .)


state 94

    (48) sense_expr -> DIRT .

    THEN            reduce using rule 48 (sense_expr -> DIRT .)
    AND             reduce using rule 48 (sense_expr -> DIRT .)
    OR              reduce using rule 48 (sense_expr -> DIRT .)
    DO              reduce using rule 48 (sense_expr -> DIRT .)


state 95

    (49) sense_expr -> OBSTACLE .

    THEN            reduce using rule 49 (sense_expr -> OBSTACLE .)
    AND             reduce using rule 49 (sense_expr -> OBSTACLE .)
    OR              reduce using rule 49 (sense_expr -> OBSTACLE .)
    DO              reduce using rule 49 (sense_expr -> OBSTACLE .)


state 96

    (50) sense_expr -> EXIT .

    THEN            reduce using rule 50 (sense_expr -> EXIT .)
    AND             reduce using rule 50 (sense_expr -> EXIT .)
    OR              reduce using rule 50 (sense_expr -> EXIT .)
    DO              reduce using rule 50 (sense_expr -> EXIT .)


state 97

    (51) sense_expr -> ENTRY .

    THEN            reduce using rule 51 (sense_expr -> ENTRY .)
    AND             reduce using rule 51 (sense_expr -> ENTRY .)
    OR              reduce using rule 51 (sense_expr -> ENTRY .)
    DO              reduce using rule 51 (sense_expr -> ENTRY .)


state 98

    (43) condition -> NOT condition .
    (44) condition -> condition . AND condition
    (45) condition -> condition . OR condition

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 43 (condition -> NOT condition .)
    DO              reduce using rule 43 (condition -> NOT condition .)
    AND             shift and go to state 91
    OR              shift and go to state 92

  ! AND             [ reduce using rule 43 (condition -> NOT condition .) ]
  ! OR              [ reduce using rule 43 (condition -> NOT condition .) ]


state 99

    (46) condition -> expr relop . expr
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 125
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 100

    (52) relop -> EQ .

    ID              reduce using rule 52 (relop -> EQ .)
    INT_LIT         reduce using rule 52 (relop -> EQ .)


state 101

    (53) relop -> NEQ .

    ID              reduce using rule 53 (relop -> NEQ .)
    INT_LIT         reduce using rule 53 (relop -> NEQ .)


state 102

    (54) relop -> LT .

    ID              reduce using rule 54 (relop -> LT .)
    INT_LIT         reduce using rule 54 (relop -> LT .)


state 103

    (55) relop -> GT .

    ID              reduce using rule 55 (relop -> GT .)
    INT_LIT         reduce using rule 55 (relop -> GT .)


state 104

    (56) expr -> term PLUS . expr
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    term                           shift and go to state 64
    expr                           shift and go to state 126
    function_call                  shift and go to state 67

state 105

    (57) expr -> term MINUS . expr
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    term                           shift and go to state 64
    expr                           shift and go to state 127
    function_call                  shift and go to state 67

state 106

    (27) stmt -> WHILE condition DO . stmt_list ENDWHILE SEMICOLON
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt_list                      shift and go to state 128
    stmt                           shift and go to state 36
    function_call                  shift and go to state 46

state 107

    (29) stmt -> TURN turn_dir SEMICOLON .

    VAR             reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    ID              reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    IF              reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    WHILE           reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    MOVE            reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    TURN            reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    CLEAN           reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    BACKTRACK       reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    REPORT          reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    RETURN          reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    RBRACE          reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    ELSE            reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    ENDWHILE        reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)
    ENDIF           reduce using rule 29 (stmt -> TURN turn_dir SEMICOLON .)


state 108

    (32) stmt -> REPORT expr SEMICOLON .

    VAR             reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    ID              reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    IF              reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    WHILE           reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    MOVE            reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    TURN            reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    CLEAN           reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    BACKTRACK       reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    REPORT          reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    RETURN          reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    RBRACE          reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    ELSE            reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    ENDWHILE        reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)
    ENDIF           reduce using rule 32 (stmt -> REPORT expr SEMICOLON .)


state 109

    (33) stmt -> RETURN expr SEMICOLON .

    VAR             reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    MOVE            reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    TURN            reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    CLEAN           reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    BACKTRACK       reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    REPORT          reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    ENDWHILE        reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)
    ENDIF           reduce using rule 33 (stmt -> RETURN expr SEMICOLON .)


state 110

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 129


state 111

    (11) type -> TYPE_INT .

    LBRACE          reduce using rule 11 (type -> TYPE_INT .)


state 112

    (12) type -> TYPE_VOID .

    LBRACE          reduce using rule 12 (type -> TYPE_VOID .)


state 113

    (16) world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT . RPAREN SEMICOLON

    RPAREN          shift and go to state 130


state 114

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT . COMMA dir RPAREN SEMICOLON

    COMMA           shift and go to state 131


state 115

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT . COMMA dir RPAREN SEMICOLON

    COMMA           shift and go to state 132


state 116

    (19) world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT . RPAREN SEMICOLON

    RPAREN          shift and go to state 133


state 117

    (20) world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT . RPAREN SEMICOLON

    RPAREN          shift and go to state 134


state 118

    (25) stmt -> ID ASSIGN expr SEMICOLON .

    VAR             reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    MOVE            reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    TURN            reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    CLEAN           reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    BACKTRACK       reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    REPORT          reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    ENDWHILE        reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)
    ENDIF           reduce using rule 25 (stmt -> ID ASSIGN expr SEMICOLON .)


state 119

    (37) function_call -> ID LPAREN arg_list_opt RPAREN .

    SEMICOLON       reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    PLUS            reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    MINUS           reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    EQ              reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    NEQ             reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    LT              reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    GT              reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    COMMA           reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    RPAREN          reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    THEN            reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    AND             reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    OR              reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)
    DO              reduce using rule 37 (function_call -> ID LPAREN arg_list_opt RPAREN .)


state 120

    (41) arg_list -> expr COMMA . arg_list
    (40) arg_list -> . expr
    (41) arg_list -> . expr COMMA arg_list
    (56) expr -> . term PLUS expr
    (57) expr -> . term MINUS expr
    (58) expr -> . term
    (59) term -> . ID
    (60) term -> . INT_LIT
    (61) term -> . function_call
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    ID              shift and go to state 65
    INT_LIT         shift and go to state 66

    expr                           shift and go to state 88
    arg_list                       shift and go to state 135
    term                           shift and go to state 64
    function_call                  shift and go to state 67

state 121

    (24) stmt -> VAR ID ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 136


state 122

    (26) stmt -> IF condition THEN stmt_list . ELSE stmt_list ENDIF SEMICOLON

    ELSE            shift and go to state 137


state 123

    (44) condition -> condition AND condition .
    (44) condition -> condition . AND condition
    (45) condition -> condition . OR condition

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 44 (condition -> condition AND condition .)
    DO              reduce using rule 44 (condition -> condition AND condition .)
    AND             shift and go to state 91
    OR              shift and go to state 92

  ! AND             [ reduce using rule 44 (condition -> condition AND condition .) ]
  ! OR              [ reduce using rule 44 (condition -> condition AND condition .) ]


state 124

    (45) condition -> condition OR condition .
    (44) condition -> condition . AND condition
    (45) condition -> condition . OR condition

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 45 (condition -> condition OR condition .)
    DO              reduce using rule 45 (condition -> condition OR condition .)
    AND             shift and go to state 91
    OR              shift and go to state 92

  ! AND             [ reduce using rule 45 (condition -> condition OR condition .) ]
  ! OR              [ reduce using rule 45 (condition -> condition OR condition .) ]


state 125

    (46) condition -> expr relop expr .

    THEN            reduce using rule 46 (condition -> expr relop expr .)
    AND             reduce using rule 46 (condition -> expr relop expr .)
    OR              reduce using rule 46 (condition -> expr relop expr .)
    DO              reduce using rule 46 (condition -> expr relop expr .)


state 126

    (56) expr -> term PLUS expr .

    EQ              reduce using rule 56 (expr -> term PLUS expr .)
    NEQ             reduce using rule 56 (expr -> term PLUS expr .)
    LT              reduce using rule 56 (expr -> term PLUS expr .)
    GT              reduce using rule 56 (expr -> term PLUS expr .)
    SEMICOLON       reduce using rule 56 (expr -> term PLUS expr .)
    COMMA           reduce using rule 56 (expr -> term PLUS expr .)
    RPAREN          reduce using rule 56 (expr -> term PLUS expr .)
    THEN            reduce using rule 56 (expr -> term PLUS expr .)
    AND             reduce using rule 56 (expr -> term PLUS expr .)
    OR              reduce using rule 56 (expr -> term PLUS expr .)
    DO              reduce using rule 56 (expr -> term PLUS expr .)


state 127

    (57) expr -> term MINUS expr .

    EQ              reduce using rule 57 (expr -> term MINUS expr .)
    NEQ             reduce using rule 57 (expr -> term MINUS expr .)
    LT              reduce using rule 57 (expr -> term MINUS expr .)
    GT              reduce using rule 57 (expr -> term MINUS expr .)
    SEMICOLON       reduce using rule 57 (expr -> term MINUS expr .)
    COMMA           reduce using rule 57 (expr -> term MINUS expr .)
    RPAREN          reduce using rule 57 (expr -> term MINUS expr .)
    THEN            reduce using rule 57 (expr -> term MINUS expr .)
    AND             reduce using rule 57 (expr -> term MINUS expr .)
    OR              reduce using rule 57 (expr -> term MINUS expr .)
    DO              reduce using rule 57 (expr -> term MINUS expr .)


state 128

    (27) stmt -> WHILE condition DO stmt_list . ENDWHILE SEMICOLON

    ENDWHILE        shift and go to state 138


state 129

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE . stmt_list RBRACE
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt_list                      shift and go to state 139
    stmt                           shift and go to state 36
    function_call                  shift and go to state 46

state 130

    (16) world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 140


state 131

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA . dir RPAREN SEMICOLON
    (62) dir -> . N
    (63) dir -> . E
    (64) dir -> . S
    (65) dir -> . W

    N               shift and go to state 142
    E               shift and go to state 143
    S               shift and go to state 144
    W               shift and go to state 145

    dir                            shift and go to state 141

state 132

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA . dir RPAREN SEMICOLON
    (62) dir -> . N
    (63) dir -> . E
    (64) dir -> . S
    (65) dir -> . W

    N               shift and go to state 142
    E               shift and go to state 143
    S               shift and go to state 144
    W               shift and go to state 145

    dir                            shift and go to state 146

state 133

    (19) world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 147


state 134

    (20) world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 148


state 135

    (41) arg_list -> expr COMMA arg_list .

    RPAREN          reduce using rule 41 (arg_list -> expr COMMA arg_list .)


state 136

    (24) stmt -> VAR ID ASSIGN expr SEMICOLON .

    VAR             reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    MOVE            reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    TURN            reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    CLEAN           reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    BACKTRACK       reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    REPORT          reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    ENDWHILE        reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)
    ENDIF           reduce using rule 24 (stmt -> VAR ID ASSIGN expr SEMICOLON .)


state 137

    (26) stmt -> IF condition THEN stmt_list ELSE . stmt_list ENDIF SEMICOLON
    (22) stmt_list -> . stmt
    (23) stmt_list -> . stmt stmt_list
    (24) stmt -> . VAR ID ASSIGN expr SEMICOLON
    (25) stmt -> . ID ASSIGN expr SEMICOLON
    (26) stmt -> . IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON
    (27) stmt -> . WHILE condition DO stmt_list ENDWHILE SEMICOLON
    (28) stmt -> . MOVE SEMICOLON
    (29) stmt -> . TURN turn_dir SEMICOLON
    (30) stmt -> . CLEAN SEMICOLON
    (31) stmt -> . BACKTRACK SEMICOLON
    (32) stmt -> . REPORT expr SEMICOLON
    (33) stmt -> . RETURN expr SEMICOLON
    (34) stmt -> . function_call SEMICOLON
    (37) function_call -> . ID LPAREN arg_list_opt RPAREN

    VAR             shift and go to state 37
    ID              shift and go to state 34
    IF              shift and go to state 38
    WHILE           shift and go to state 39
    MOVE            shift and go to state 40
    TURN            shift and go to state 41
    CLEAN           shift and go to state 42
    BACKTRACK       shift and go to state 43
    REPORT          shift and go to state 44
    RETURN          shift and go to state 45

    stmt_list                      shift and go to state 149
    stmt                           shift and go to state 36
    function_call                  shift and go to state 46

state 138

    (27) stmt -> WHILE condition DO stmt_list ENDWHILE . SEMICOLON

    SEMICOLON       shift and go to state 150


state 139

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 151


state 140

    (16) world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .

    SIZE            reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    ENTRY_DEF       reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    EXIT_DEF        reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    OBSTACLE_DEF    reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    DIRT_DEF        reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    RBRACE          reduce using rule 16 (world_stmt -> SIZE LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)


state 141

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir . RPAREN SEMICOLON

    RPAREN          shift and go to state 152


state 142

    (62) dir -> N .

    RPAREN          reduce using rule 62 (dir -> N .)


state 143

    (63) dir -> E .

    RPAREN          reduce using rule 63 (dir -> E .)


state 144

    (64) dir -> S .

    RPAREN          reduce using rule 64 (dir -> S .)


state 145

    (65) dir -> W .

    RPAREN          reduce using rule 65 (dir -> W .)


state 146

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir . RPAREN SEMICOLON

    RPAREN          shift and go to state 153


state 147

    (19) world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .

    SIZE            reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    ENTRY_DEF       reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    EXIT_DEF        reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    OBSTACLE_DEF    reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    DIRT_DEF        reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    RBRACE          reduce using rule 19 (world_stmt -> OBSTACLE_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)


state 148

    (20) world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .

    SIZE            reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    ENTRY_DEF       reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    EXIT_DEF        reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    OBSTACLE_DEF    reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    DIRT_DEF        reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)
    RBRACE          reduce using rule 20 (world_stmt -> DIRT_DEF LPAREN INT_LIT COMMA INT_LIT RPAREN SEMICOLON .)


state 149

    (26) stmt -> IF condition THEN stmt_list ELSE stmt_list . ENDIF SEMICOLON

    ENDIF           shift and go to state 154


state 150

    (27) stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .

    VAR             reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    ID              reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    IF              reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    WHILE           reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    MOVE            reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    TURN            reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    CLEAN           reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    BACKTRACK       reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    REPORT          reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    RETURN          reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    RBRACE          reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    ELSE            reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    ENDWHILE        reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)
    ENDIF           reduce using rule 27 (stmt -> WHILE condition DO stmt_list ENDWHILE SEMICOLON .)


state 151

    (5) function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE .

    AGENT           reduce using rule 5 (function_decl -> FUNC ID LPAREN param_list_opt RPAREN RETURNS type LBRACE stmt_list RBRACE .)


state 152

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 155


state 153

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 156


state 154

    (26) stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF . SEMICOLON

    SEMICOLON       shift and go to state 157


state 155

    (17) world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .

    SIZE            reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    ENTRY_DEF       reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    EXIT_DEF        reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    OBSTACLE_DEF    reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    DIRT_DEF        reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    RBRACE          reduce using rule 17 (world_stmt -> ENTRY_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)


state 156

    (18) world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .

    SIZE            reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    ENTRY_DEF       reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    EXIT_DEF        reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    OBSTACLE_DEF    reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    DIRT_DEF        reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)
    RBRACE          reduce using rule 18 (world_stmt -> EXIT_DEF LPAREN INT_LIT COMMA INT_LIT COMMA dir RPAREN SEMICOLON .)


state 157

    (26) stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .

    VAR             reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    ID              reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    IF              reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    WHILE           reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    MOVE            reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    TURN            reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    CLEAN           reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    BACKTRACK       reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    REPORT          reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    RETURN          reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    RBRACE          reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    ELSE            reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    ENDWHILE        reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)
    ENDIF           reduce using rule 26 (stmt -> IF condition THEN stmt_list ELSE stmt_list ENDIF SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 98 resolved as shift
WARNING: shift/reduce conflict for OR in state 98 resolved as shift
WARNING: shift/reduce conflict for AND in state 123 resolved as shift
WARNING: shift/reduce conflict for OR in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
